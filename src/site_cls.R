# TODO: Add comment Author: lenovo Two-step way to find the chronsequence of forest community after disturnances Step 1: DCA and vegclst at whole dataset,
# then produce several site-groups; Step 2: redo step 1 with subgroup data generated by step 1 seperately.
# ---------------------------------------------------------------------------------- Another consideration of dominant species X age X ABG X comm Step 1:
# to inditify the indicator species using
require(stats)
require(doBy)
require(vegclust)
require(vegan)
require(reshape2)
require(graphics)
# -------------

function(ddata, bins, resolution) {
    # Function to create a histogram of non-zero data for use in the mix.dist program !! REQUIRES THAT THE PACKAGE 'mixdist' IS ATTACHED !!  Call:
    # mix.dist.hist <- make.mix.data(ddata, bars, resolution) ddata: array of single value, non-zero, variables bins: Number of groups in the histogram
    # data.out: A two dimensional array of histogram-type grouped data with first column the upper bound value of the interval and second column the number of
    # values in the interval
    data.out <- matrix(0, bins, 2)
    nvals <- length(ddata)
    # Create histogram intervals
    max.ddata <- max(ddata)
    min.ddata <- min(ddata)
    offset <- (max.ddata - min.ddata)/resolution
    a <- min.ddata
    inter <- ((offset + max.ddata) - (min.ddata - offset))/bins
    for (i in 1:bins) {
        a <- a + inter
        data.out[i, 1] <- a
    }
    # Partition the data into bins
    for (i in 1:nvals) {
        k <- 1
        calc.x <- ddata[i] - min.ddata
        while (calc.x > inter) {
            calc.x <- calc.x - inter
            k <- k + 1
        }
        data.out[k, 2] <- data.out[k, 2] + 1
    }
    data.out <- as.mixdata(as.data.frame(data.out))
    data.out
}

sumfun <- function(x, ...) {
    c(m = mean(x, ...), md = median(x, ...), v = sd(x, ...), l = length(x))
}

fst2maxi <- function(x, ...) {
    c(which.max(x, ...), which.max(x[-which.max(x)]))
}

fst2max <- function(x, ...) {
    c(max(x), max(x[-which.max(x)]))
}


# ---------------------------------------- Data prepa r#####################################################
xxalp <- read.csv("all.csv", colClasses = c(rep("character", 2), rep("numeric", 5)))
# cross area at breast height(1.3m) unit: cm2
xxalp$cab <- xxalp$xj * xxalp$xj * pi/4

xxalp$xxjj <- xxalp$xj/xxalp$jj

tree.spec <- as.character(unlist(levels(as.factor(xxalp$zwmcbh))))
site.lst <- as.character(unlist(levels(as.factor(xxalp$ydID))))

nsite <- length(site.lst)
nspec <- length(tree.spec)

# QA XJ-JJ
ooxxjj <- (xxalp$xxjj > 1)
ooxxjj2 <- (xxalp$xxjj <= 1)

for (i in 1:nsite) {
    for (j in 1:nspec) {
        ooii <- (xxalp$ydID %in% site.lst[i]) & (xxalp$zwmcbh %in% tree.spec[j])
        ii <- which(ooii & ooxxjj)
        if ((length(ii) > 0)) {
            jj <- which(ooii & ooxxjj2)
            if (length(jj) > 0) {
                xxalp$jj[ii] <- predict(xxalp$xj[jj], lm(xxalp$jj[jj] ~ xxalp$xj[jj]))
            }
        }
        # xxalp$xxjj[ii]<-median(xxalp$xxjj[jj]); xxalp$jj[ii]=xxalp$xj[ii]/median(xxalp$xxjj[jj])}
    }
}

ctbl <- as.data.frame(matrix(ncol = 2, nrow = nsite * nspec))
names(ctbl) <- c("ydID", "zwmcbh")
cc <- merge(tree.spec, site.lst)
ctbl[, 1] <- cc[, 2]
ctbl[, 2] <- cc[, 1]
rm(cc)

# ctbl[,1:2]<-as.character(ctbl[,1:2]);

# To generate site X species table for important value calculation
table.topr <- as.data.frame(matrix(0, ncol = nspec, nrow = nsite))
names(table.topr) <- tree.spec
row.names(table.topr) <- site.lst

# tables: importance value; relative density; relative coverage; relative frequency.
tbl.impV <- tbl.rden <- tbl.rcvg <- tbl.rfrq <- table.topr

# density by plot and speces
rden.1 <- summaryBy(xj ~ ydID + zwmcbh, data = xxalp, FUN = length)

rfrq.1 <- summaryBy(xj ~ ydID + zwmcbh + xyfID, data = xxalp, FUN = length)
# frequency by plot and speces
rfrq2.1 <- summaryBy(xyfID ~ ydID + zwmcbh, data = rfrq.1, FUN = length)
# total cutting area by plot and speces
rcvg.1 <- summaryBy(cab ~ ydID + zwmcbh, data = xxalp, FUN = sum)

# --to reshape these calculation into real table------

# ----relative density :: rden.2
rden.2 <- merge(ctbl, rden.1, all = T)
names(rden.2)[3] <- "rden"

chick_m <- melt(rden.2, id = 1:2, na.rm = FALSE)
rden.2 <- acast(chick_m, ydID ~ zwmcbh, sum, na.rm = T)

# ----relative frequency :: rfrq
rfrq.2 <- merge(ctbl, rfrq2.1, all = T)
names(rfrq.2)[3] <- "rfrq"

chick_m <- melt(rfrq.2, id = 1:2, na.rm = FALSE)
rfrq.2 <- acast(chick_m, ydID ~ zwmcbh, sum, na.rm = T)
# -------relative coverage :: rcvg.2
rcvg.2 <- merge(ctbl, rcvg.1, all = T)
names(rcvg.2)[3] <- "rcvg"

chick_m <- melt(rcvg.2, id = 1:2, na.rm = FALSE)
rcvg.2 <- acast(chick_m, ydID ~ zwmcbh, sum, na.rm = T)

# ---------normalization to calculate important values：rimp
rden.3 <- rden.2/apply(rden.2, 1, sum, na.rm = T)
rfrq.3 <- rfrq.2/36
rcvg.3 <- rcvg.2/apply(rcvg.2, 1, sum, na.rm = T)

rimp <- (rden.3 + rfrq.3 + rcvg.3)/3

# ---------Simpson Index:: simp_idx
simp_idx = 1 - apply(rden.3 * rden.3, 1, sum)

# dominant species :: dom_spec
dom_spec <- as.data.frame(matrix(ncol = 4, nrow = nrow(rimp)))
row.names(dom_spec) <- row.names(rimp)
names(dom_spec) <- c("max_spec", "max", "max2_spec", "max2")
f2max = apply(rimp, 1, fst2max)
f2maxi <- apply(rimp, 1, fst2maxi)

dom_spec[, c(1, 3)] <- colnames(rimp)[t(f2maxi)]
dom_spec[, c(2, 4)] <- t(f2max)

# dominant species and plot number of XXAL 白桦 斑叶稠李 稠李 臭冷杉 春榆 风桦 蒿柳 黑桦 红皮云杉 红松 胡桃楸 苹 糠椴 65 1 1 15 16 3 1 6 9 28 3 1 1
# 裂叶榆 落叶松 毛赤杨 蒙古栎 青楷槭 色木槭 山杨 水曲柳 榆树 樟子松 紫椴 1 80 6 44 1 5 11 10 1 21 1

win.graph(width = 6, height = 4)
par(mfrow = c(1, 2))
plot(density(dom_spec[, 2]), main = "第一建群种优势度概率密度")
grid()
abline(v = mean(dom_spec[, 2]))
plot(density(dom_spec[, 4]), main = "第二建群种优势度概率密度")
grid()
abline(v = mean(dom_spec[, 4]))


win.graph()
heatmap(rimp)
########################## Polulation age structure TO indentify the development staus according to Whipple, S., Dix, R. (1979). Age Structure and Successional Dynamics of a
########################## Colorado Subalpine Forest. American Midland Naturalist 101(1): 142-158.  exponential distribution: Gammar-distribution: Log-normal Distribution Normal
########################## Distribution bimodal distribution Weibull distribution -or--------- A: unimodal distribution - peak in the middle J: unimodal - peak at either end U:
########################## bimodal - peaks at both ends S: bimodal or multimodal - multiple peaks

require(fitdistrplus)
# the normalmixEM procedure for fitting normal mixture densities
require(mixtools)
require(flexmix)
require(mixdist)


fitW <- fitdist(serving, "weibull")
fitg <- fitdist(serving, "gamma")
fitln <- fitdist(serving, "lnorm")
summary(fitW)
summary(fitg)
summary(fitln)
cdfcomp(list(fitW, fitg, fitln), legendtext = c("Weibull", "gamma", "lognormal"))
denscomp(list(fitW, fitg, fitln), legendtext = c("Weibull", "gamma", "lognormal"))
qqcomp(list(fitW, fitg, fitln), legendtext = c("Weibull", "gamma", "lognormal"))
ppcomp(list(fitW, fitg, fitln), legendtext = c("Weibull", "gamma", "lognormal"))
gofstat(list(fitW, fitg, fitln), fitnames = c("Weibull", "gamma", "lognormal"))

########################## community analysis ###########################################

# -----------DCA+hclust
vgne.dca <- decorana(rimp)
summary(vgne.dca)
win.graph()
plot(vgne.dca, display = "species")
win.graph()
plot(vgne.dca, display = "sites")

hca <- (hclust(dist(vgne.dca[[1]][, 1:4])^2, method = "average"))
plot(hca)
x <- rect.hclust(hca, k = 18, border = "red")
x

# ----------FUzzy clulster vgne.fcm = vegclust(rimp, mobileCenters=12,method='FCM', nstart=12)
vgne.fcm = vegclust(vgne.dca[[1]][, 1:4], mobileCenters = 12, method = "FCM", nstart = 12)
## Fuzzy membership matrix
vgne.fcm$memb
## Cardinality of fuzzy clusters (i.e., the number of objects belonging to each cluster)
vgne.fcm$size
## Obtains membership vector
group <- defuzzify(vgne.fcm$memb)$cluster
gcr <- paste("M", 1:12, sep = "")

win.graph()
plot(x = vgne.dca[[1]][ii, 1] - 3.32, y = vgne.dca[[1]][ii, 2] - 1.85, type = "n", xlim = c(-3.5, 3), ylim = c(-2, 2.5), xlab = "DCA1", ylab = "DCA2", main = "小兴安岭调查样地群落类型数量分类")
for (i in 1:12) {
    ii <- which(group == gcr[i])
    # text(x=vgne.dca[[1]][ii,1],y=vgne.dca[[1]][ii,2],substr(row.names(rimp),12,15)[ii],col=i+1)
    text(x = vgne.dca[[1]][ii, 1] - 3.32, y = vgne.dca[[1]][ii, 2] - 1.85, dom_spec[ii, 1], col = rainbow(12)[i], cex = 0.75)
}
abline(h = 0, v = 0, lty = 3)

# ----------------------Next step:: DCCA, envn variables: age, ABG, lat, long, elv, soil_depth, aspect ----------------------- 
